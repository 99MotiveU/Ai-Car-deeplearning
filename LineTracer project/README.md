# 🤖 OpenCV 기반 라즈베리파이 자율주행 라인트레이서

> 이 프로젝트는 라즈베리파이와 카메라를 '눈'으로 사용하여 바닥의 검은색 선을 따라 스스로 주행하는 자율주행 로봇입니다. **OpenCV**의 강력한 이미지 처리 기능을 통해 실시간으로 주행 경로를 인식하고, **Python**과 **RPi.GPIO** 라이브러리를 이용해 모터를 정밀하게 제어합니다.

이 프로젝트를 통해 임베디드 시스템, 컴퓨터 비전, 그리고 실시간 제어의 기본 원리를 통합적으로 학습할 수 있습니다.

<p align="center">
  <img src="https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white" />
  <img src="https://img.shields.io/badge/OpenCV-5C3EE8?style=for-the-badge&logo=opencv&logoColor=white" />
  <img src="https://img.shields.io/badge/NumPy-013243?style=for-the-badge&logo=numpy&logoColor=white" />
  <img src="https://img.shields.io/badge/Raspberry_Pi-A22846?style=for-the-badge&logo=raspberry-pi&logoColor=white" />
</p>

---

## ⚙️ 하드웨어 구성 (Bill of Materials)

이 프로젝트를 제작하는 데 필요한 주요 부품 목록입니다.

| 부품 | 세부 사양 및 역할 |
| :--- | :--- |
| **라즈베리파이** | **Raspberry Pi 4 Model B** 또는 **3B+** 권장. 로봇의 두뇌 역할을 합니다. |
| **카메라 모듈** | **Raspberry Pi Camera Module V2** 또는 호환 가능한 USB 웹캠. 차선 영상을 촬영합니다. |
| **DC 모터** | **기어드 DC 모터 x2**. 로봇의 좌/우측 바퀴를 구동합니다. |
| **모터 드라이버** | **L298N** 또는 **TB6612FNG** 등. 라즈베리파이의 약한 신호로 강력한 모터를 제어합니다. |
| **로봇 섀시** | 2륜 또는 4륜 로봇 차체. 모든 부품을 고정하는 뼈대입니다. |
| **보조배터리** | **5V, 3A 이상** 출력. 라즈베리파이와 모터에 안정적인 전원을 공급합니다. |
| **기타** | 점퍼선, 미니 브레드보드, 나사, 볼 캐스터 등 |

---

## 🧠 핵심 동작 원리

알고리즘은 **`이미지 입력 → 처리 및 분석 → 판단 → 모터 제어`** 의 순환 루프로 구성됩니다.

### 1단계: 이미지 입력 및 전처리
- **카메라 캡처:** `cv2.VideoCapture(0)`를 통해 160x120의 저해상도 영상을 연속적으로 캡처하여 처리 속도를 높입니다.
- **관심 영역 (ROI) 설정:** 전체 영상 중 차선이 존재할 가능성이 높은 **하단부 영역만 잘라내어** 불필요한 연산을 줄입니다.
- **그레이스케일 변환:** 색상 정보는 필요 없으므로, `cv2.cvtColor`를 사용해 3채널 컬러 이미지를 1채널 흑백 이미지로 변환합니다.
- **노이즈 제거:** `cv2.GaussianBlur`를 적용하여 이미지의 미세한 노이즈를 부드럽게 만들어 다음 단계의 정확도를 높입니다.

### 2단계: 차선 검출 및 분석
- **이진화 (Thresholding):** `cv2.threshold` 함수로 특정 임계값(코드에서는 130)을 기준으로 픽셀을 **완전한 검은색 또는 흰색으로** 나눕니다. `THRESH_BINARY_INV` 옵션은 검은색 선을 흰색으로, 배경을 검은색으로 만들어 분석하기 쉽게 합니다.
- **마스크 정제:** `cv2.erode` (침식)와 `cv2.dilate` (팽창) 연산을 통해 검출된 선 주변의 작은 노이즈 픽셀을 제거하고, 끊어진 선을 자연스럽게 이어줍니다.
- **무게 중심 계산:** `cv2.findContours`로 분리된 선의 외곽선을 찾고, `cv2.moments`를 이용해 가장 큰 외곽선(차선)의 **기하학적 중심점(cx, cy)**을 계산합니다. 이 `cx` 값이 바로 차선의 현재 위치입니다.

### 3단계: 상황 판단 및 모터 제어
- 계산된 차선의 중심점 `cx`가 화면의 어느 위치에 있는지에 따라 로봇의 움직임을 결정합니다.
- **`cx`가 화면 중앙 (66-94px)에 있을 경우:** 차선을 잘 따라가고 있다는 의미이므로 `motor_go()` 함수를 호출해 **직진**합니다.
- **`cx`가 화면 왼쪽 (39-65px)으로 치우친 경우:** 로봇이 차선의 오른쪽으로 벗어났다는 의미이므로 `motor_right()` 함수를 호출해 **우회전**하여 차선을 다시 중앙으로 가져옵니다.
- **`cx`가 화면 오른쪽 (95-125px)으로 치우친 경우:** 로봇이 차선의 왼쪽으로 벗어났다는 의미이므로 `motor_left()` 함수를 호출해 **좌회전**합니다.

---

## 🔌 GPIO 핀 연결 정보

코드를 기반으로 한 GPIO 핀맵입니다. (BCM 모드 기준)

| 모터 드라이버 핀 | 라즈베리파이 GPIO | 역할 |
| :--- | :--- | :--- |
| **PWMA** | `18` | **좌측 모터** 속도 제어 (PWM) |
| **AIN1** | `22` | **좌측 모터** 방향 제어 1 |
| **AIN2** | `27` | **좌측 모터** 방향 제어 2 |
| **PWMB** | `23` | **우측 모터** 속도 제어 (PWM) |
| **BIN1** | `25` | **우측 모터** 방향 제어 1 |
| **BIN2** | `24` | **우측 모터** 방향 제어 2 |

---

## ▶️ 설치 및 실행 방법

1.  **라이브러리 설치:**
    ```bash
    pip install opencv-python numpy RPi.GPIO
    ```

2.  **라즈베리파이 설정:**
    - `sudo raspi-config` 명령어를 통해 **Interfacing Options**에서 **Camera**를 활성화합니다.

3.  **스크립트 실행:**
    - 코드를 `line_follower.py`와 같은 이름으로 저장합니다.
    - 터미널에서 다음 명령어로 스크립트를 실행합니다.
    ```bash
    python line_follower.py
    ```

4.  **프로그램 종료:**
    - 실행 중인 카메라 창을 선택하고 키보드에서 **'q'** 키를 누르면 프로그램이 안전하게 종료되며 GPIO 핀이 초기화됩니다.

---

## 🚀 향후 개선 방안

- **PID 제어 도입:** 현재의 On/Off 방식 제어보다 훨씬 부드럽고 정밀한 회전 및 주행이 가능해집니다.
- **속도 가변 제어:** 차선과의 거리(오차)에 비례하여 회전 속도를 조절하면 더욱 안정적인 주행이 가능합니다.
- **장애물 감지:** 초음파 센서를 추가하여 전방에 장애물이 있을 경우 주행을 멈추거나 회피하는 기능을 구현할 수 있습니다.
